/*탐사 로봇의 귀환 경로 (BFS)
문제 설명
당신은 외계 행성에 불시착한 탐사 로봇을 원격으로 조종하고 있습니다. 로봇은 (1행 1열) 위치에서 출발하
여, 구조 신호를 송신할 수 있는 탑승선이 있는 (n행 m열) 지점까지 이동해야 합니다.
하지만 행성 지표면에는 이동할 수 없는 암석 지대(0) 와, 이동 가능한 평지(1) 가 섞여 있어, 로봇은 평지 위
로만 움직일 수 있습니다.
로봇은 오직 상하좌우 네 방향으로 한 칸씩만 이동할 수 있으며, 지도를 벗어날 수는 없습니다.
로봇이 탑승선에 도달하기 위해 거쳐야 할 최소 칸 수를 구해주세요.
단, 탑승선까지 도달할 수 없는 경우에는 -1을 반환해야 합니다.
입력 형식
maps : n x m 크기의 2차원 배열.
1 : 이동 가능한 평지
0 : 암석 지대 (이동 불가)
시작 위치: (1, 1)
목표 위치: (n, m)
출력 형식
로봇이 (n, m) 지점까지 도달하기 위해 지나야 하는 칸 수의 최솟값을 반환합니다.
만약 도달할 수 없다면 1 을 반환합니다.
 */

function solution(maps) {
  const n = maps.length; // 세로
  const m = maps[0].length; // 가로
  const dx = [-1, 0, 1, 0]; // 칸 이동 로직에 쓰임 (세로축)
  const dy = [0, -1, 0, 1]; // 칸 이동 로직에 쓰임 (가로축)

  // n x m 크기의 거리 기록용 사각형 생성
  const d = Array.from({ length: n }, () => Array(m).fill(0));
  const queue = [];

  queue.push([0, 0]); // 시작점
  d[0][0] = 1; // 시작점은 이동 가능 블록임
  maps[0][0] = 0; // 방문여부 (0이면 이동 불가 로직에 쓰임)

  //여기까지 기본설정 끝

  // queue 에 아무것도 없을때까지 반복
  while (queue.length) {
    let [x, y] = queue.shift(); // queue에서 꺼낸 좌표를 x,y에 구조분해 할당

    for (let k = 0; k < 4; k++) {
      // 상하좌우 탐색
      let nx = x + dx[k]; // 배열 이동은 세로로
      let ny = y + dy[k]; // 배열 속 인덱스 이동은 가로로

      // 사각형 범위를 벗어나지 않으면서 이동가능한 경우(1) 큐에 추가
      if (0 <= nx && nx < n && 0 <= ny && ny < m && maps[nx][ny] === 1) {
        queue.push([nx, ny]);
        maps[nx][ny] = 0;
        d[nx][ny] = d[x][y] + 1; // 이전 이동 거리에서 1을 더해줌
      }
    }
  }
  return d[n - 1][m - 1] || -1; // n과 m은 length 값이므로 -1씩, 목표 위치 도달 못할 시 -1 반환
}
console.log(
  solution([
    [1, 1, 0, 1],
    [0, 1, 0, 1],
    [0, 1, 1, 1],
    [1, 0, 0, 1],
  ])
);
console.log(
  solution([
    [1, 0, 0],
    [1, 0, 0],
    [1, 1, 1],
  ])
);
console.log(
  solution([
    [1, 0, 1],
    [0, 0, 1],
    [1, 1, 1],
  ])
);
